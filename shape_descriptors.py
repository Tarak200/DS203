# -*- coding: utf-8 -*-
"""shape_descriptors.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c-qfOAP8vYla7peYzrbR59cQ-hFw4ig3
"""

import zipfile
import os
import pandas as pd

def unzip_and_save(zip_file_path, output_dir):
    # Create the output directory if it doesn't exist
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # Extract files from the zip archive
    with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
        zip_ref.extractall(output_dir)

    print("Files extracted successfully.")

# Example usage
zip_file_path = "/content/E7-images.zip"
output_dir = "/content/extracted_files"

unzip_and_save(zip_file_path, output_dir)

def get_convexity_score(contour):

  # Calculate area of the contour
  area = cv2.contourArea(contour)

  # Get convex hull and calculate its area
  hull = cv2.convexHull(contour)
  hull_area = cv2.contourArea(hull)

  # Avoid division by zero (set score to 1 for very small areas)
  convexity_score = 1 - (area / (hull_area + 1e-6)) if hull_area > 0 else 1

  return convexity_score

def get_convexity_corners(contour):

  # Calculate the convex hull
  hull = cv2.convexHull(contour, clockwise=False)

  # Count the number of hull points (assuming each point is a corner)
  num_corners = len(hull)

  return num_corners

def get_aspect_ratio(contour):
  # Get the bounding rectangle of the contour
  x, y, w, h = cv2.boundingRect(contour)

  # Calculate and handle division by zero (avoid NaNs)
  aspect_ratio = float(w) / h if h != 0 else 0

  return aspect_ratio

"""function for getting features"""

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

def features_img(img_path):
  img = cv2.imread(img_path)

  # Check if the image is loaded successfully
  if img is None:
      print("Error: Unable to load image. Please check the file path.")
      exit()

  # Convert to HSV color space for better color segmentation
  hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
  #print(hsv.shape)
  # Define HSV range for orange color
  lower_yellow = np.array([0, 100, 100])   # Lower HSV range for orange
  upper_yellow = np.array([30, 255, 255])  # Upper HSV range for orange

  # Create mask for yellow region
  yellow_mask = cv2.inRange(hsv, lower_yellow, upper_yellow)

  # Apply morphological operations for noise reduction (optional)
  kernel = np.ones((3, 3), np.uint8)
  yellow_mask = cv2.morphologyEx(yellow_mask, cv2.MORPH_OPEN, kernel)

  # Edge detection using Canny edge filter
  edges = cv2.Canny(yellow_mask, 10, 20)  # Adjust thresholds for edge detection

  # Apply morphological closing to strengthen edges (optional)
  edges = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel)

  # Find contours of the edges (potential boundaries)
  contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

  # Count the number of straight lines using Hough Line Transform
  lines = cv2.HoughLines(edges, 1, np.pi / 180, threshold=60)  # Adjust threshold as needed


  # calculation of perimeter and area of contour
  perimeter = cv2.arcLength(contours[0], True)
  area = cv2.contourArea(contours[0])

  #aspect ratio calculation
  aspect_ratio = get_aspect_ratio(contours[0])

  # higher the convexity score, higher the convexity of the shape
  convexity_score = get_convexity_score(contours[0])
  hull_corners = get_convexity_corners(contours[0])

  #calculation of symmetry score
  # Calculate Hu Moments
  moments = cv2.moments(contours[0])
  hu_moments = cv2.HuMoments(moments).flatten()
    # higher the symmetry score, lower the symmetry
  symmetry_measure = np.sum(np.abs(hu_moments[1:4])) / np.sum(np.abs(hu_moments))

  #get the features
  # print("Number of straight lines detected: ",lines.shape[0] )
  # print("Perimeter: ",perimeter)
  # print("Area: ",area)
  # print("symmetry_score: ", symmetry_measure)
  # print("convexity_score: ", convexity_score)

  features = [lines.shape[0], perimeter, area, symmetry_measure, convexity_score, hull_corners, aspect_ratio]

  # Optionally, visualize the contours and edges
  cv2.drawContours(img, contours, -1, (0, 255, 0), 2)
  #cv2_imshow(img)
  #cv2.imwrite("img_boundary_line.jpg", img)
  cv2.waitKey(0)

  return features

def files_read(directory_path):

  # List all files in the directory
  files = os.listdir(directory_path)

  features_map = {}
  count = 0
  key_list = []
  for file in files:
    if '.jpg' in file:
      file_path = os.path.join(directory_path,file)
      #print(file)
      features = features_img(file_path)
      key = file[:-4]
      key_list.append(key)
      features_map[key] = features
      count = count+1
      # if(count==2):
      #   break
  # Create the DataFrame using pd.DataFrame.from_dict()
  df = pd.DataFrame.from_dict(features_map, orient='index', columns=['edges', 'perimeter', 'area', 'symmetry-score', 'convexity-score', 'convexity-hull corners','aspect_ratio'])
  df = df.rename_axis('image_name')
  df = df.sort_values(by='image_name', ascending=True)
  return df, key_list

# Path to the directory containing files
directory_path = "/content/extracted_files"
df, key_list = files_read(directory_path)
print(df)

df['area'] = df['area']/max(df['area'])
df['perimeter'] = df['perimeter']/max(df['perimeter'])
print(df)

"""Knn model for classification

"""

import pandas as pd
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt

# Compute inertia for different values of k
inertia = []
for k in range(1, 11):
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(df)
    inertia.append(kmeans.inertia_)

# Plot the inertia curve
plt.plot(range(1, 11), inertia, marker='o')
plt.xlabel('Number of clusters (k)')
plt.ylabel('Inertia')
plt.title('Inertia Curve for K-means Clustering')
plt.show()

"""Knn for categorising based on complexity"""

# Perform kNN clustering
k = 3  # Number of clusters
kmeans = KMeans(n_clusters=k)
kmeans.fit(df)

# Get the cluster labels assigned to each data point
cluster_labels = kmeans.labels_

# Add cluster labels to the DataFrame
df['Cluster'] = cluster_labels

# Print the DataFrame with cluster labels
print(df)

key_list.sort()
df['image_no'] = key_list
df.head()

# Get the count of unique values in the 'Category' column
unique_value_counts = df['Cluster'].value_counts()

print(unique_value_counts)

import shutil

# Source directory path
source_dir = "/content/extracted_files"

# Destination directory path
destination_dir = "/content"

# Create directories for each cluster if they don't exist
for cluster in range(3):
    cluster_dir = os.path.join(destination_dir, f"cluster_{cluster}")
    os.makedirs(cluster_dir, exist_ok=True)

# Loop through each image in the DataFrame and copy them to the corresponding cluster directory
for index, row in df.iterrows():
    image_no = row['image_no']
    cluster = row['Cluster']
    source_file = f"{image_no}.jpg"
    source_file_path = os.path.join(source_dir, source_file)
    destination_file_path = os.path.join(destination_dir, f"cluster_{cluster}", source_file)
    shutil.copy(source_file_path, destination_file_path)

print("Images copied successfully.")