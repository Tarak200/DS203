# -*- coding: utf-8 -*-
"""Hellinger_Distances.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zJd9PvceIb1tbB34Z3Lb1rZiiESnK6J9
"""

# importing libraries
import cv2
import os
import zipfile
import numpy as np
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow
from sklearn.preprocessing import StandardScaler
import pandas as pd

zip_file_path = '/content/E7-images.zip'
extract_path = '/content/extracted_images'
with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
    zip_ref.extractall(extract_path)

# Get a list of image files in the extracted folder
image_files = [os.path.join(extract_path, f) for f in os.listdir(extract_path) if f.endswith('.jpg')]

# List to store Hellinger distances
hellinger_distances = []

for image_path in image_files:
      # Load the image
      image = cv2.imread(image_path)

      # Convert the image to grayscale
      gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

      # Apply Gaussian blur to reduce noise
      blurred = cv2.GaussianBlur(gray, (5, 5), 0)

      # Apply Canny edge detection
      edges = cv2.Canny(blurred, 50, 150)

      # Find contours
      contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)

      # Draw contours on the original image
      contour_image = cv2.drawContours(image.copy(), contours, -1, (0, 255, 0), 2)

      # Display the original image with contours using matplotlib
      plt.imshow(cv2.cvtColor(contour_image, cv2.COLOR_BGR2RGB))
      plt.axis('off')
      plt.show()

      boundary_points = np.vstack(contours).squeeze()

      # Plotting the boundary points on the grayscale image
      plt.figure(figsize=(8, 8))
      plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
      plt.scatter(boundary_points[:, 0], boundary_points[:, 1], color='red', s=5)  # Plot boundary points as red dots
      plt.title("Image with Boundary Points")
      plt.xlabel("X")
      plt.ylabel("Y")
      plt.show()

      # Now count the number of boundary points with the finer contour approximation
      num_boundary_points = len(boundary_points)
      num_boundary_points

      M = cv2.moments(contours[0])

      # Calculate centroid only if the contour
      cx = int(M['m10'] / M['m00'])
      cy = int(M['m01'] / M['m00'])
      print("Centroid (cx, cy):", cx, cy)

      # Plotting the histogram and marking the centroid
      plt.figure(figsize=(10, 5))

      # Image with centroid
      plt.subplot(1, 2, 2)
      plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
      plt.title("Image with Centroid")
      plt.scatter([cx], [cy], color='red') # Centroid marked in red

      plt.tight_layout()
      plt.show()

      # Calculate distances from centroid to boundary points
      distances_to_boundary = np.sqrt((boundary_points[:, 0] - cx) ** 2 + (boundary_points[:, 1] - cy) ** 2)
      print(distances_to_boundary)
      # Calculate the frequency histogram of these distances
      histogram_boundary_frequency, boundary_bins = np.histogram(distances_to_boundary,
          bins=100,  # Define the number of bins
          range=(np.min(distances_to_boundary), np.max(distances_to_boundary))
      )

      # Calculate bin centers from bin edges for plotting
      bin_centers = (boundary_bins[:-1] + boundary_bins[1:]) / 2

      # Plot the frequency histogram with the detailed boundary data
      plt.figure(figsize=(10, 5))
      plt.bar(bin_centers, histogram_boundary_frequency, width=np.diff(boundary_bins), align='center', color='green', edgecolor='black')
      plt.title("Frequency Histogram of Distances from Centroid to Boundary")
      plt.xlabel("Distance from Centroid to Boundary")
      plt.ylabel("Frequency (Number of Boundary Points)")
      plt.xlim(np.min(distances_to_boundary), np.max(distances_to_boundary))  # Set the x-axis limits
      plt.grid(axis='y', alpha=0.75)
      plt.show()

      # Append the histogram data to the list for Hellinger distance calculation
      hellinger_distances.append(histogram_boundary_frequency)

hellinger_results = []
for i in range(len(hellinger_distances) - 1):
    for j in range(i + 1, len(hellinger_distances)):
        hist1 = hellinger_distances[i]
        hist2 = hellinger_distances[j]
        # Calculate Hellinger distance
        hellinger_dist = (np.sqrt(np.sum((np.sqrt(hist1) - np.sqrt(hist2))**2)) / np.sqrt(2)) / 10
        if hellinger_dist < 0.2:
            hellinger_results.append({
                'Image Pair': f'Image {i+1} - Image {j+1}',
                'Hellinger Distance': hellinger_dist
            })

# Create a DataFrame from the filtered Hellinger results
df = pd.DataFrame(hellinger_results)

# Save the DataFrame to an Excel file
excel_file_path = '/content/hellinger_distances_filtered.xlsx'
df.to_excel(excel_file_path, index=False)